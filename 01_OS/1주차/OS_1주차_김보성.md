# 📌 운영체제

## ✅ 개념

- 운영체제는 사용자가 컴퓨터를 사용하기 위해 필요한 시스템 소프트웨어
- 우리가 일반적으로 컴퓨터를 사용하면서 모든 프로그램들은 운영체제에서 관리하고 제어 한다고 보면 된다
  - ex) Windows, Linux, Mac OS, iOS 등

## ✅ 목적

### 1. 컴퓨터 시스템의 효율적 운영 (하드웨어 관리도 포함)

- 하드웨어를 잘 제어하고 관리하여 시스템 자원을 효율적으로 활용하기 위함
- 컴퓨터 시스템? (4계층 구조)
  - 사용자 ↔ 응용 프로그램 ↔ 운영체제 ↔ 하드웨어
- 하드웨어란 : 실제 물리적인 장치
  - CPU, 메모리, 디스크, 키보드, 마우스, 모니터 등
  - 하드웨어 자원을 운영체제가 적절히 배분하고, 충돌 없이 관리
    → 운영체제의 성능이 컴퓨터의 전체 성능과 관계가 크다고 볼 수 있음!

### 2. 사용자에게 편의를 제공하는 목적

- 하드웨어나 복잡한 시스템 구조를 몰라도 응용 프로그램만 사용해서 컴퓨터를 쉽게 조작

![image4](https://github.com/user-attachments/assets/46d01d45-379f-4559-96fc-5d5e1f437308)


- 그림처럼 사용자는 그냥 멜론만 클릭해서 사용하면 운영체제가 알아서 하드웨어를 관리하여 쉽게 사용할 수 있도록 해줌!

## ✅ 핵심 역할

### 1. 프로세스 관리

- 실행 중인 프로그램(프로세스)을 생성, 스케줄링, 종료 하는 역할
- 운영체제는 CPU를 누구에게 얼마나 줄지 결정
- 여러 작업을 동시에 진행할 수 있게 보이게 만들어 줌 → 이걸 스케줄링이라고 함
  - 멜론 앱으로 음악, 크롬으로 검색, vscode로 코딩
    → 이 모든 프로세스가 동시에 돌아가도록 CPU 시간 분배
    -> 우선순위랑 상태, 요청 자원등을 보고 CPU가 계속 재분배 해줌!!
    ![image3](https://github.com/user-attachments/assets/78cc42f6-6ca3-4dc7-bb89-2a2adb873f2f)


### 2. 메모리 관리

- RAM을 효율적으로 나누고 보호
  - RAM은 일시적으로 저장하는 휘발성 메모리! → 컴퓨터 끄면 저장한거 사라짐 ㅠ
- 여러 프로세스가 동시에 안정적으로 실행하게 끔 도와줌!
  - 멜론 앱과 크롬이 동시에 실행 되지만 메모리 충돌이 일어나지 않게 해줌

### 3. 파일 시스템 관리

- 데이터를 파일 단위로 저장, 조회, 삭제할 수 있게 쉽게 만듬
- 저장 장치에서의 데이터 관리, 접근 권한 제어 등의 기능 제공
  - 파일 탐색기에서 이름 검색하면 쉽게 찾는 것 처럼!

### 4. 입출력 장치 관리

- 사용자가 키보드, 마우스 등으로 조작 하면 알아서 운영체제가 중간에서 처리 해줌!
  - 장치 드라이버를 통해 대신 처리해줌!
  - 키보드르 눌렀을 때 화면에 글자 뜨는 순서
    → 키보드 입력 → 운영체제가 읽음 → 문자 처리 후 모니터 출력

## ✅ 그 외의 역할

### 5. 네트워크 관리

- 운영체제는 컴퓨터가 다른 컴퓨터들과 **네트워크를 통해 통신할 수 있도록 지원**함
- 네트워크 장비와의 연결을 관리하고, **데이터 전송의 흐름 제어**, **오류 처리**, **보안 설정** 등을 수행

### 예시

- IP 주소 설정, 포트 제어, 네트워크 인터페이스 관리
- 네트워크 연결 상태 확인 (`ping`, `netstat`)
- 서버에서 수신한 요청 처리 및 전송 제어

### 6. 보조 스토리지 관리

- 스토리지 할당, 여유 공간 관리, 디스크 스케줄링
- 하드디스크(HDD), SSD, USB 등 **영구 저장 장치**를 효율적으로 관리함
- 운영체제가 직접 **공간을 할당하고**, **빈 공간을 추적하며**, **디스크 스케줄링 알고리즘**으로 성능 최적화

### 예시

- 디스크 읽기/쓰기 요청을 스케줄링 (FCFS, SSTF 등)
- 파티션 관리, 저장 용량 확인, 파일 삭제 후 공간 회수 등

### 7. 보안 관리

- 시스템 보호 및 오류로 인한 시스템 손상 방지
- **외부 침입**, **악성 코드**, **권한 없는 접근**으로부터 시스템을 보호함
- 사용자 권한과 접근 제어, 암호화, 방화벽 설정 등을 포함

### 예시

- 리눅스의 `chmod`, `sudo` 명령어로 파일 권한 설정
- 시스템 로그인 시 사용자 인증 (ID/PW 확인)
- 안티바이러스, 방화벽, SELinux 같은 보안 모듈

### 8. 명령어 해석 시스템

- 사용자와 시스템 간의 인터페이스, 인터프리터, 쉘 등
- 사용자가 입력한 **텍스트 명령어를 해석해서 실행**하는 인터페이스
- \*쉘(Shell)\*\*이 대표적인 명령어 해석 시스템으로, 사용자와 커널 사이의 인터페이스 역할

### 예시

- 리눅스의 `bash`, `zsh`, Windows의 `cmd`, `PowerShell`
- 사용자가 `ls`, `cd`, `mkdir` 같은 명령어 입력 → 커널에게 전달되어 실제 동작 수행

# 📌 커널

## ✅ 개념

- 운영체제의 핵심!!!
- 하드웨어를 직접 제어하는 역할
- 커널은 커널 공간이라는 곳에 위치!
- 사용자가 쉘(Shell)을 통해 입력한 명령어를 해석하여 하드웨어에 전달해주는 역할
- 위에서 말한 운영체제가 하는 기능들을 사실 커널이 실제로 담당하는 거임!
  - 쉽게 말하면 커널은 운영체제의 심장! → 컴퓨터, 하드웨어 자원을 통제하는 최고 관리자!!
  - 메모리 관리
  - 프로세스 관리 및 CPU 스케쥴링
  - 입출력 장치와 같은 컴퓨터에 연결된 장치들 관리
  - 시스템 콜 인터페이스 및 보안
- CPU에는 두가지 실행 모드가 있음
  - User Mode : 일반 프로그램이 동작하는 제한된 모드
  - Kernel Mode : 운영체제가 동작하는 권한 있는 모드
                                 → 하드웨어 직접 제어 가능 O

## ✅ 쉘

### 개념

- 사용자와 하드웨어 간의 번역 역할을 담당
- 사람이 이해하기 쉬운 형태로 된 명령어를 입력 → 쉘이 기계가 이해하기 쉬운 형태로 해석
  → 커널에 전달
- 쉘(Shell)은 운영체제의 사용자 인터페이스 중 하나로,**사용자의 명령어를 해석해서 커널에 전달하고**, 그 결과를 다시 사용자에게 보여주는 **중간 관리자** 역할을 함
- CLI (Command Line Interface)**와 **GUI (Graphical User Interface)\*\* 모두 쉘의 일종

### 기능

- 명렁어 해석 기능
  - 대표적인 기능
  - 사용자가 입력한 명령어 → 기계어로 번역 → 커널에서 수행한 결과를 다시 번역 → 사용자
  - 인터프리터 역할 수행!
- 명령어 이력 기능
  - 사용자가 이전에 입력했던 명령어를 화살표 키로 다시 불러올 수 있음
  - `history`, `!!`, `!n` 같은 기능
- 파이프 & 리디렉션 기능
  - 명령어의 출력 결과를 다른 명령어의 입력으로 넘기거나, 파일로 저장할 수 있음
  - 예: `ls | grep txt`, `cat file.txt > output.txt`
- 프로그래밍 기능
  - 쉘 스크립트를 작성하여 반복적으로 수행하는 작업을 프로그램으로 만들 수 있음
- 사용자 환경 설정 기능

  - 명령을 호출하는 경로, 파일의 권한 설정, 환경 변수들을 초기화 파일에 저장
  - 이 파일을 이용해 사용자가 로그인할 때마다 설정이 반영 되게 할 수 있음

- 주요 쉘 종류
  - **sh**: 가장 기본적인 Unix 셸
  - **bash**: 가장 널리 쓰이는 Linux 셸 (Bourne Again SHell)
  - **zsh**: 자동완성, 하이라이팅 등 편의성 강화된 셸
  - **fish**: 사용자 친화적인 modern 셸
  - **PowerShell**: Windows의 셸 (객체 기반, cmd랑 다름)

### 마무리 요약

- 쉘은 **사용자 ↔ 운영체제(커널)** 사이의 대화 통역기 역할을 하며, 명령어 해석, 환경 설정, 스크립트 실행 등 다양한 기능을 제공하는 **강력한 도구**

## ✅ 동작하는 방식

- 응용 프로그램은 직접 하드웨어에 접근 XX
- 응용 프로그램은 커널에게 <시스템 콜>로 요청함
  - 시스템 콜 : 사용자나 응용 프로그램이 컴퓨터 자원을 사용하기 위해서 사용, 함수 형태
  - ex) open()
- 커널은 하드웨어에게 명령을 내리고 사용자에게 전달
  1. 멜론 앱이 파일을 열려고 함
  2. 앱에서 open()이라는 시스템 콜을 요청 → 이를 통해 Kernel Mode로 전환
  3. 커널이 디스크에서 파일을 읽고 앱에 전달 → 하면 다시 User Mode로 전환

![image2](https://github.com/user-attachments/assets/8add1451-2f78-4f46-9913-96ebfeb4c757)


## ✅ 커널의 종류 (운영체제 아키텍처 관점)

- 모놀리식 커널 : 기능이 한 덩어리로 커널 내부에 존재
- 마이크로 커널 : 최소한의 핵심 기능만 커널에 넣고, 나머지는 사용자 영역에서 실행
                                   ex) 프로세스 관리, 메모리 관리, 프로세스 통신

# 📌 프로세스 vs 스레드

## ✅ 프로세스

### 개념

- 실행중인 프로그램!
- 운영체제가 독립적인 메모리 공간을 할당해서 관리하는 단위

### 예시

- 크롬 실행 → 크롬 프로세스가 생김
- vscode를 실행 → vscode 프로세스가 생김
- 멜론 앱을 실행 → 멜론 프로세스가 생김 (쉽죠?)

### 특징

- 완전히 독립 (서로의 메모리, 데이터 접근 X)
- 하나가 죽어도 다른 프로세스엔 영향 X
- 생성/전환 비용이 큼 (메모리, 리소스까지 따로 생성해야 하니까)

## ✅ 프로세스 상태

- 프로세스는 실행되는 동안 아래와 같은 상태를 가짐

| 상태              | 설명                           |
| ----------------- | ------------------------------ |
| New               | 생성 중인 상태 (아직 실행 전)  |
| Ready             | 실행될 준비가 되어 큐에서 대기 |
| Running           | 실제로 CPU를 점유하고 실행 중  |
| Waiting (Blocked) | I/O 등 외부 작업을 기다리는 중 |
| Terminated        | 실행이 끝난 상태               |

➡ 운영체제는 이 상태 정보를 참고해서 어떤 프로세스에게 CPU를 줄지 결정함

---

## ✅ 왜 스케줄링이 필요한가?

- 동시에 많은 프로세스가 실행 대기 중이기 때문!
- CPU는 하나 (또는 몇 개)뿐이므로, **공정하게 시간 분배** 필요
- 사용자 경험을 좋게 하기 위해 **우선순위 기반, 응답 시간 보장** 등의 스케줄링 전략 사용

➡ 그래서 운영체제는 스케줄러를 통해 **누구를 먼저 실행할지 결정**함!

## ✅ 스레드

### 개념

- 하나의 프로세스 안에서 작업 단위를 나눈 것!

### 예시

- 멜론 앱(프로세스)안에서
  - 한 스레드는 음악 재생
  - 다른 스레드는 앨범 이미지 다운로드

### 특징

- 같은 프로세스 내부에서 여러 스레드가 실행 됨!
  - 하나의 프로세스 안에서 여러개의 스레드가 존재할 수 있음
- 메모리 공간 공유
  - 프로세스 안이니까 당연히 공유
- 생성/ 전환 비용이 작다
- 공유 메모리로 인한 충돌 가능성 있음
  - 예를 들어 같은 변수에 두개 이상의 스레드가 접근해서 수정하는 경우
    → 데이터가 꼬이게 됨!! (이를 경쟁 상태 “Race Condtion” 이라고 함)
    → 그렇기 때문에 동기화가 필요함!!

### 📝 하나로 모아보기!

| 항목     | 프로세스                | 스레드                           |
| -------- | ----------------------- | -------------------------------- |
| 개념     | 실행 중인 프로그램      | 프로세스 내부 작업 단위          |
| 메모리   | 독립된 메모리 공간      | 같은 공간 공유                   |
| 안정성   | 충돌 적음               | 충돌 가능성 있음 (공유된 데이터) |
| 생성비용 | 큼                      | 작음                             |
| 예시     | 크롬, 멜론 같은 앱 전체 | 음악 재생 + 다운로드 동시에 처리 |

![image](https://github.com/user-attachments/assets/254d19f3-ee54-41a1-bddc-373df2f01f13)


- 그림 설명
  - 이런식으로 하나의 프로레스를 집이라고 생각하고 스레드들은 안에서 일하는 사람들!
  - 집(프로레스)은 서로 독립되어 있고 집안의 사람들(스레드)은 같은 집(자원)을 쓴다!

## ✅ 멀티

### 1. 멀티프로세스

- 그림처럼 여러개의 프로세스(집)를 동시에 실행
  - ex) 멜론 프로세스도 있고 크롬 프로세스도 있는 것
- 근데 실제로는 CPU가 한번에 하나의 작업만 실행 할 수 있기 때문에
  → 운영체제가 CPU 시간을 아주 짧게 나눠서 각 프로세스에 번갈아가며 실행 시킴
  → 그래서 사람의 눈으로는 여러 프로그램이 동시에 돌아가는 것 처럼 보이는 것!!!
- 요새는 멀티코어 CPU 라고 4코어면 4개의 작업을 동시에 실행하여 병렬로 처리 가능

### 2. 멀티스레드

- 그림처럼 여러개의 스레드(사람)이 동시에 일하는 것
  - ex) 멜론 앱 안에서
    - 음악재생
    - 다운로드
    - 이미지 보여주기

### 3. 멀티태스킹

- 운영체제가 여러 작업을 동시에 처리하는 것처럼 만드는 기술! (스케줄링과는 다른 개념)
  - 멀티태스킹은 사용자 입장에서 “여러 작업이 동시에 잘 돌아가는구나~” 생각하면 되는거고
  - 스케줄링은 운영체제 입장에서 “어느 작업을 먼저 실행 시키고 몇 초정도를 줄까?” 라고 생각
    - 한 마디로 멀티태스킹은 그냥 우리가 보는 결과물, 스케줄링은 가능하게 하는 내부 기술

# 📌 컨텍스트 스위칭

## ✅ 개념

- CPU가 현재 실행 중인 작업(프로세스 또는 스레드)의 상태를 저장하고, 다른 작업으로 전환할 때 상태를 복원하는 과정

## ✅ 컨텍스트 스위칭의 흐름

1. 프로세스 A 실행 중 B는 실행을 기다리고 있는 상태
2. 운영체제가 프로세스 B를 실행하겠다고 함
3. 그러면 현재의 A의 상태를 저장
4. B의 상태를 복원하여 실행

- 예시
  → vscode로 코딩 중인데 알림창(크롬 알림)이 뜸
  → CPU가 그러면 잠깐 알림창 쪽으로 전환
  → 작업 상태 저장/불러오기를 하면서 컨텍스트 스위칭 발생

## ✅ 언제 발생하는가?

- 주어진 Time Slice를 다 사용했을 때
  - 무슨 얘기냐면 CPU는 각 프로세스에 일정 시간만 할당함
  - 이 시간이 끝나면 다음 프로세스에게 CPU를 넘겨줘야 하므로 발생
- I/O 작업을 해야할 때
  - 파일 읽기, 프린트 출력 등을 요청할 때
  - CPU는 대기할 필요 없이 다른 작업에게 넘겨주기 때문에 발생
- 다른 리소스를 기다려야 할 때
  - CPU 외에 잠깐 접근할 수 없는 리소스(메모리, 락, DB 등)를 기다려야 한다면?
  - CPU가 현재 프로세스를 멈추고 다른 프로세스 할당해서 발생!
- 인터럽트 (간단 설명 : 일하던 중 끼어들기!)

  - 외부 장치나 시스템 이벤트(키보드 입력, 타이머 알람)가 발생하면
  - 현재 실행 중인 작업을 멈추고 처리할 작업으로 전환할 때 발생

- 공통점
  - CPU를 더 이상 쓸 수 없거나 운영체제가 다른 작업 먼저 처리하겠다고 판단할 때 발생!!!

## ✅ 사용 이유

- 여러 프로세스와 스레드들을 동시에 실행시키기 위해(그렇게 보이기 위해)
- 여러 프로세스와 스레드들이 공정하게 CPU 시간을 나눠 갖기 위해
- 높은 우선순위의 작업이 빠르게 처리될 수 있게

## ✅ 주의할 점 (오버헤드)

- 컨텍스트 스위칭은 상태 저장/복원 때문에 **시간이 소모됨**
- 너무 자주 발생하면 오히려 성능 저하가 생김 → **오버헤드 발생**

### 캐시 오염 (Cache Pollution)

- 컨텍스트 스위칭이 일어나면 CPU 캐시에 저장된 데이터도 바뀌게 됨
- 자주 바뀌면 자주 쓰던 데이터가 밀려나서 캐시 성능이 떨어짐
  → 이게 바로 ‘캐시오염’ 인거임!
- 결국 스위칭이 너무 잦으면 캐시 적중률이 낮아지고 전체 시스템 성능이 하락할 수 있음
