# 운영체제의 역할

- `운영체제의 역할 (프로세스 관리, 메모리 관리, 파일 시스템 등)`

## 운영체제의 역할 : 시스템의 자원을 관리하는 관리자

사용자와 하드웨어간의 중간다리 역할

## 운영체제의 정의

컴퓨터에서 항상 동작하는 하나의 프로그램

### 넓은 의미의 운영체제 : 시스템 소프트웨어 전반

### 좁은 의미의 운영체제 : 제어 프로그램(kernel)

![image](https://github.com/user-attachments/assets/23b1af9d-a8a4-4b10-a63a-e21b59195b21)


### 시스템 자원 = CPU, MEMORY, I/O DISK 등등…

### 시스템 자원의 분배

- 각 프로세스마다 CPU를 얼마나 사용하도록 할 지에 대한 분배
- 프로그램이 메모리의 어떤 주소에 어느 정도의 공간을 활용해서 저장할지에 대한 분배
- 프로그램을 어디에 저장할지에 대한 결정
- I/O 장치의 입력에 대한 처리와 입력된 신호에 대한 출력 처리 결정

<aside>
💡

프로그램이란?

→ set of instructions, 명령어들의 집합이다.

운영체제 역시 프로그램이다.

</aside>

### 컴퓨터 HW와 SW 제어

- 응용프로그램의 실행과 동작에 대한 관리
- 프로세스 / 메모리 / 파일 / 디스크 / 입출력에 대한 관리
- 네트워킹 제어와 컴퓨터 보호(보안)
- 컴퓨터 하드웨어의 동작에 대한 제어

<img width="528" alt="image2" src="https://github.com/user-attachments/assets/98786f32-83cb-4a23-9f25-eb3da19343f9" />


### 사용자와 컴퓨터 간의 의사소통 지원

→ 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공한다.

### 유저 인터페이스 제공

### Process, Thread 관리

- 프로세스에 CPU 배분, 작업 환경 제공

---

# 커널

- `커널(User Mode vs Kernel Mode)`

## Multi-mode CPU

CPU는 두가지 모드가 존재한다.

- user mode
- kernel mode

Privileged instruction은 커널 모드에서만 실행이 가능함

- 일반 애플리케이션이 유저모드에서 privileged instruction을 실행하려고 하면 예외가 발생할 수 있다.

이러한 구조 덕분에 **운영체제(OS)는 자신과 시스템의 다른 핵심 구성 요소들을 보호**할 수 있다.

- 즉, 중요한 작업(critical things)과 일반 작업(general things)을 분리해서 보호한다.

**최신 CPU**들은 **2개 이상의 모드(멀티 모드)를 지원**

## 유저모드에서 커널 모드로 전환하기

- **By interrupt**
    - **보통 하드웨어에 의해 발생한다.**
    - 비동기적(Asynchronous)이다. → 언제든지 발생할 수 있다.
    - 인터럽트가 발생하면, **인터럽트 핸들러로 넘어가기 전에 커널 모드로 전환된다.**
- **By system call**
    - 동기적(Synchronous)
    - **보통 소프트웨어에 의해 발생**

✅ CPU는 인터럽트가 발생하면 → **커널 모드로 전환** → **인터럽트 핸들러 실행**

✅ 처리 끝나면 → **다시 User Mode로 복귀**해서 프로그램 계속 실행

<img width="661" alt="image3" src="https://github.com/user-attachments/assets/945eeea5-c8d1-418e-97ac-63c2154af057" />


인터럽트에 해당하는 그림

<img width="725" alt="image4" src="https://github.com/user-attachments/assets/ec283884-c602-4443-a70d-d9efc7f5ceeb" />


시스템 콜에 해당하는 그림

# 프로세스 VS 스레드

`프로세스 vs 스레드 (멀티 프로세스, 멀티 스레드)`

### 프로그램

- 실행되기 전의 명령어 집합으로, 특정 작업을 수행하기 위해 작성된 정적인 코드다.

### 프로세스란 무엇일까?

<aside>
💡

프로세서(Processor) → CPU 
실제로 계산하고 명령어를 처리하는 하드웨어이다.

</aside>

컴퓨터에는 CPU가 1개 밖에 없다. (요즈음의 컴퓨터에는 더 많이 탑재되어있지만 기본적인 OS를 공부할 때의 가정은 CPU가 하나이다.)

이러한 CPU는 한번에 하나의 작업만 처리 가능하다.

운영체제에서 **Process**는 **Processor(CPU)**를 Abstract 한 것이다.

→ **"CPU 1개"를 여러 개처럼 쪼개서 '가상으로' 여러 작업이 실행되는 것처럼 만들어주는 것**이 **프로세스라는 추상화**

즉, 프로세스는 CPU라는 물리적 자원을 가상화한 논리적 실행 단위

<img width="479" alt="image5" src="https://github.com/user-attachments/assets/d9df0bce-1192-4071-acdf-f4b2d258788a" />


- **메모리에 올라와 실행 중인 프로그램의 인스턴스**
- 운영체제(OS)가 프로그램을 실행해서 메모리에 올리고, CPU가 작업을 수행 중인 상태
- 동적 entity이다.
- **특징:**
    - 독립적인 메모리 공간(코드, 데이터, 스택, 힙)을 가짐
    - 각 프로세스는 서로 독립적 → 다른 프로세스의 메모리에 직접 접근 불가능
    - 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신 (IPC)를 사용해야 한다.
    - 프로세스마다 **PID(Process ID)** 부여
    - 프로세스당 최소 1개의 스레드를 가지고 있다.
- **예시:**
    - `chrome.exe` 프로그램을 실행 → 메모리에 `chrome` 프로세스 생성
    
![image6](https://github.com/user-attachments/assets/b511412f-a011-4036-94c8-accfee13834e)

    

### From Program to Process

<img width="551" alt="image7" src="https://github.com/user-attachments/assets/d97bb10a-bf7e-4def-b4d9-e6ecf5653936" />


### 프로그램 상태

- 프로그램은 Disk(저장장치)에 .exe 와 같은 형태로 저장.
    - .exe와 같은 프로그램 실행파일 내부에 Code, Data 영역 정보가 있다.
    - 아직 메모리에 올라가지 않은 정적인 상태이다.

### 프로그램 실행 → 메모리 Load

- 사용자가 프로그램 실행하면 OS가 실행파일을 읽어 메모리에 올린다.
- 메모리에 올라가는 순간 Process Address Space가 생성된다.

### CPU가 실행 (Process 상태)

- 메모리에 올라온 후, CPU가 PC(프로그램 카운터)를 통해 Code 영역 명령어를 읽으며 실행한다.
- SP(Stack Pointer)는 스택의 맨 윗부분을 가리킨다.
- 이 순간부터 프로그램이 프로세스로 전환된다.

### 📍 프로세스 메모리 구조 (Address Space):

| 영역 | 설명 |
| --- | --- |
| **Code** | 프로그램 명령어가 들어감 (CPU가 실행할 부분) |
| **Data** | 초기화된 전역변수, 정적 변수 |
| **Heap** | 동적 할당 영역 (`malloc`, `new`) |
| **Stack** | 함수 호출 시 생기는 지역변수 저장 (LIFO 구조) |

### 요약

디스크에 있는 프로그램 파일이 메모리로 올라오면 Process Address Space 생성, CPU 실행 시작시 프로세스가 되어 실제 동작하는 프로그램이 된다.

프로세스 내부

![image8](https://github.com/user-attachments/assets/7831ecc8-5cc9-4fb5-a333-87893b531117)


하나의 프로그램으로 여러개의 프로세스를 사용할 수 있다.

각각의 프로세스는 own address space가 메모리에 존재한다.

프로세스의 개수가 엄청 많은데, 뭘 실행할지 어떤식으로 구분을 해야할까?

### States of Process

<img width="551" alt="image9" src="https://github.com/user-attachments/assets/832f4044-a7e4-49c7-90a7-3812bb96a3af" />


New: 프로세스가 생성된 상태

Ready: 프로세스가 프로세서에게 할당받기를 기다리는 상태

Running: 인스트럭션들이 실행중이다.

blocked : 사용자의 입력을 기다리는 상태. CPU의 자원 할당을 받지 못한 상태이다.

Exited: 실행 종료

### 중간 정리

1. 프로그램은 정적인 상태의 실행전 코드 집합이다.
2. 프로세스는 운영체제로부터 자원을 할당 받아 메모리에 올라와 실행 중인 프로그램이다.
3. 스레드는 프로세스 내에서 실행 흐름의 최소 단위이다.

> 프로세스는 운영체제로부터 자원을 할당받는 작업의 단위이고 스레드는 프로세스가 할당받은 자원을 이용하는 실행의 단위이다.
> 

프로세스는 

1. 만드는 역할을 하는 프로세스 → Parent
2. 만들어지는 역할을 하는 프로세스 → Child

Parent는 하나가 존재하고, child는 여러개이다. → 트리구조

![image10](https://github.com/user-attachments/assets/07222143-c181-451f-ba08-d65d31dbe64d)


### Process Creation

- fork(): duplicate 복제의 역할
- exec() : 현재 들고 있는 프로세스의 address space를 초기화. 지정된 program으로 대체하는 시스템 콜 → 주소공간이 날아간다

### Process Termination

- exit()
- kill()

## Implementing Processes

### Process Control Block(PCB)

![image11](https://github.com/user-attachments/assets/b416be52-54db-4c53-9f2b-05b97114aae3)


만약 fork()를 사용하여 process를 생성한다면?

→ 해당 프로세스에 대응되는 PCB가 OS 내부에 생성된다.

Process number → PID

- ✅ **프로세스의 정보를 저장하는 운영체제의 자료구조**
- ✅ 운영체제가 **프로세스를 관리하고 추적**하기 위해 사용하는 "신분증" 같은 역할
- ✅ 프로세스가 생성되면 PCB가 하나 만들어지고, 종료되면 사라짐

컨텍스트 스위칭 할 때 필수로 사용하는 정보 덩어리이다.

### 스레드

- **정의:**
    - **프로세스 내에서 실제로 작업을 수행하는 실행 단위**
    - 하나의 프로세스 안에서 여러 개 생성될 수 있음 (멀티스레딩)
- **특징:**
    - 프로세스의 메모리(코드, 데이터, 힙)를 공유
    - 독립적인 **스택(Stack)** 영역만 가짐
    - CPU가 실제로 스케줄링하는 단위
    - 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드(sibling thread)도 그 변경 결과를 즉시 볼 수 있다.
    - 스레드가 수행되는 환경을 Task 라고 한다.
- **예시:**
    - `chrome` 프로세스 안에서 탭마다 별도의 스레드가 생성되어 동작
    - 게임 실행 중, 캐릭터 움직임과 배경음악 재생이 서로 다른 스레드로 처리됨

## 멀티 프로세스와 멀티 스레드의 차이

### 멀티 프로세스

**멀티프로세스란 하나의 응용 프로그램이 여러 개의 독립적인 프로세스로 구성되어, 각 프로세스가 하나 이상의 작업을 병렬로 처리하는 방식이다.**

![image12](https://github.com/user-attachments/assets/0c8a0d6a-6402-4c59-ac95-5eebd3f2e360)


각 프로세스 간 메모리 구분이 필요하거나 독립된 주소 공간을 가져야 할 경우 사용

ex) 크롬 

→ 하나의 프로그램이지만 각 탭을 별도의 프로세스로 만들어서 동작시킨다.

- **특징**
    - 프로세스 간 메모리는 독립적이다.
    - 하나가 죽어도 다른 프로세스는 정상 동작한다. (크롬의 탭)
    - 프로 세스 간 데이터 공유 어렵다 (IPC 요구 됨)
    - 여러개의 프로세스가 처리되어야 할 때 동일한 데이터를 사용하고, 이러한 데이터를 하나의 디스크에 두고 모든 프로세서(`CPU`)가 이를 공유하면 비용적으로 저렴하다.
- 오버헤드

## **멀티프로세스의 오버헤드 발생 원리**

### ✅ **1. 독립된 메모리 공간**

- 멀티프로세스 구조에서는 **프로세스마다 독립적인 메모리 공간**(코드, 데이터, 힙, 스택)을 가짐
- 이 때문에 프로세스 간 **주소 공간을 공유하지 않음**
- 데이터를 주고받으려면 **IPC(Inter-Process Communication)** 기법 필요 (파이프, 소켓, 공유 메모리 등)
- 작업량이 많아지고 프로세스 간 통신이 많아질수록 비용 증가

### ✅ **2. Context Switching 발생**

- CPU는 한 번에 하나의 프로세스만 실행
- 여러 프로세스를 번갈아가며 실행 
→ **Context Switching** 발생
- Context Switching 시 수행하는 작업:
    1. **현재 실행 중인 프로세스의 상태 저장** (레지스터, 프로그램 카운터, 스택 포인터 등)
    2. **다음 프로세스의 상태 복원**
    3. **캐시 초기화(Flush)** - CPU가 이전 프로세스의 데이터 캐시를 비우고, 새 프로세스의 데이터로 채워야 함

### ✅ **3. 캐시 메모리 초기화로 인한 성능 저하**

- CPU 내부의 **캐시(Cache)** 는 처리 속도를 높이는 핵심 요소
- 프로세스가 전환될 때마다 **캐시 데이터가 무효화(Flush)** 됨
- 다시 캐시를 채우는 과정에서 **메모리 접근 시간이 증가** → 성능 저하 발생
- 특히, **작업량이 많고 프로세스 전환이 자주 발생**하면 **오버헤드 증가 → 성능 급락**

### 멀티 스레드

<aside>
💡

한 프로세스가 하나의 스레드를 이용하여 한 번에 한 작업만 수행하는 것은 싱글스레드

한 프로세스가 여러 스레드로 동시에 여러 작업을 수행하는 것은 멀티 스레드라고 한다.

</aside>

![image13](https://github.com/user-attachments/assets/c7adec97-ee7a-40d5-8f58-0d60c528e4f9)


- 스레드는 프로세스의 메모리 공간(코드, 데이터, 힙)을 공유
- 스택은 따로 가진다.
- CPU는 스레드 단위로 작업을 스케줄링하고 실행한다.

### 특징

| **1. 응답성 (Responsiveness)** | - 작업을 스레드로 분리해 무거운 작업 중에도 사용자 입력에 실시간 응답 가능
- GUI, 서버 프로그램 등에서 사용자 경험 향상 |
| --- | --- |

| **2. 자원 공유 (Resource Sharing)** | - 같은 프로세스 내에서 힙, 데이터 영역 공유- 스레드 간 통신 비용 적고 빠름
- 별도의 IPC 불필요 |
| --- | --- |

| **3. 경제성 (Economy)** | - 프로세스 생성보다 스레드 생성 비용 훨씬 낮음
- Context Switching 비용도 적음 (캐시 유지)
- 실제로 Solaris 기준 스레드 생성이 30배 빠르고, 전환 속도도 5배 빠름 |
| --- | --- |

| **4. 확장성 (Scalability)** | - 멀티코어 CPU 환경에서 각 스레드가 여러 코어에서 병렬 처리 가능
- 고성능 처리 구조로 확장 쉬움 |
| --- | --- |

| **5. 시스템 자원 소모 감소** | - 프로세스 생성/관리 비용 절감
- 메모리, 시스템 콜 사용 감소로 자원 효율성 증가 |
| --- | --- |

| **6. 시스템 처리율 향상** | - 스레드 간 데이터 교환이 간편하고 빠름
- 시스템 오버헤드 감소로 전체 처리 속도 향상 |
| --- | --- |

| **7. 빠른 Context Switching** | - 같은 프로세스 내 전환이기 때문에 캐시 초기화 부담 없음
- 작업량 작아 전환 속도 빠름 |
| --- | --- |

| **8. 통신 비용 절감 및 응답 시간 단축** | - 힙 영역 공유로 데이터 주고받기 쉬움
- 간단한 통신 구조 덕분에 응답 시간 짧아짐 |
| --- | --- |

# 컨텍스트 스위칭

- `컨텍스트 스위칭`

## 수행중인 프로세스가 변경될 때 레지스터에 존재하는 프로세스의 정보가 
바뀌는 것 이다.

### 컨텍스트 스위치가 필요한 이유

→ 멀티태스킹 구현을 위해 반드시 필요

컨텍스트 스위치는 **한정된 CPU 자원을 여러 프로세스가 번갈아가며 쓰기 위해 꼭 필요한 과정**

컨텍스트 스위치를 통해 **멀티태스킹(다중 작업)처럼 보이게 만들어준다.**

## 📌 **컨텍스트 스위치 (Context Switch)**

- CPU가 **다른 프로세스로 전환할 때**, 시스템은 **현재 프로세스의 상태를 저장하고**, **다음 프로세스의 상태를 불러와야 한다**.

- 프로세스의 **컨텍스트(Context)**는 **PCB(Process Control Block, 프로세스 제어 블록)** 안에 저장된다.

- **컨텍스트 스위치 시간은 오버헤드**로 간주된다.
    - **스위칭하는 동안 시스템은 실제로 유용한 작업을 하지 않는다**.
    - **운영체제와 PCB가 복잡해질수록 컨텍스트 스위치에 걸리는 시간도 길어진다**.

- 컨텍스트 스위치 시간은 **하드웨어 지원 여부**에 따라서도 달라진다.
    - 일부 하드웨어(예: **Sun UltraSPARC**)는 CPU당 **여러 개의 레지스터 세트**를 제공하기 때문에
    - **CPU 안에 여러 개의 컨텍스트를 유지**할 수 있다.

컨텍스트 스위치는 CPU가 다른 프로세스로 전환하는 과정으로, 이때 저장하고 불러오는 작업 자체가 **성능 오버헤드**다. 하드웨어가 좋으면(레지스터 세트 많으면) 이 시간을 줄일 수 있다.

┌────────────────────────┐
│    CPU 실행 → Process A │
└────────────────────────┘
↓ (인터럽트 발생)
┌────────────────────────┐
│  A의 Context 저장 (PCB)  │
└────────────────────────┘
↓
┌────────────────────────┐
│  B의 PCB에서 Context 불러오기   │
└────────────────────────┘
↓
┌────────────────────────┐
│    CPU 실행 → Process B │
└────────────────────────┘


<img width="690" alt="image14" src="https://github.com/user-attachments/assets/3f448b75-dc42-4583-8955-e5fa02648540" />





